<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unity on Effectiveさお</title>
    <link>http://h-sao.com/tags/unity/</link>
    <description>Recent content in Unity on Effectiveさお</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 08 May 2016 14:00:00 +0900</lastBuildDate>
    <atom:link href="http://h-sao.com/tags/unity/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[Unity] PC実行時のWindowsサイズの設定の仕方＆起動時フック</title>
      <link>http://h-sao.com/blog/2016/05/08/change-unity-window-size/</link>
      <pubDate>Sun, 08 May 2016 14:00:00 +0900</pubDate>
      
      <guid>http://h-sao.com/blog/2016/05/08/change-unity-window-size/</guid>
      <description>

&lt;p&gt;Unityのバグなのか、わたしの使い方が悪いのか？&lt;br /&gt;
PC実行時のウィンドウサイズの設定が、思うようにできなかったので&lt;br /&gt;
その解決メモです&lt;/p&gt;

&lt;h1 id=&#34;pcで実行したら全画面:a0801ebf74281b4200348d8e7619641e&#34;&gt;PCで実行したら全画面…&lt;/h1&gt;

&lt;p&gt;Unityのプロジェクトファイルを新規作成して&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;File&amp;rdquo; → &amp;ldquo;Build &amp;amp; Run&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;を選択すると、ビルドが走り、実際に exe が実行されます&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Change-Unity-window-size_01.png&#34; style=&#34;border:solid 5px #e6e6e6&#34;/&gt;&lt;/p&gt;

&lt;p&gt;へぇ、画面解像度( Screen resolution )とか、ここで変えることが出来るんだ～&lt;br /&gt;
と思って解像度設定を変更し、&amp;rdquo;Play!&amp;rdquo; で起動させると、いちおう思ったサイズで起動することが出来ます&lt;/p&gt;

&lt;h1 id=&#34;unityプロジェクトに-plyaer-settings-がある:a0801ebf74281b4200348d8e7619641e&#34;&gt;Unityプロジェクトに Plyaer Settings がある&lt;/h1&gt;

&lt;p&gt;ユーザに毎回ウィンドウサイズを選択させるのも、なんだかねぇ…ということで、ちゃんと設定したいと思います&lt;/p&gt;

&lt;p&gt;Unityのメニューの&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;File&amp;rdquo; → &amp;ldquo;Build Settings&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Build Settings を選択すると、ビルドに関する設定が変更できるようです&lt;br /&gt;
下にある、&amp;rdquo;Player Settings&amp;rdquo; を選択すると、
インスペクタウィンドウが出ます&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Change-Unity-window-size_00.png&#34; style=&#34;border:solid 5px #e6e6e6&#34;/&gt;&lt;/p&gt;

&lt;p&gt;ここで、起動時の Player Settings が出来るようですが…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Change-Unity-window-size_02.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;「Resolution」 の 「&lt;strong&gt;Default Is Full Screen&lt;/strong&gt;」 のチェックボックスを外しましょう&lt;br /&gt;
ついでに、「Standalone Player Options」 の &lt;strong&gt;「Display Resolution Dialog」 を　「Disable」&lt;/strong&gt;　にしておきます&lt;/p&gt;

&lt;p&gt;これで exe を実行するたびに 「FixSizeWindows Configuration」 は開かなくなります&lt;/p&gt;

&lt;p&gt;「Resolution」 には、「Default Screen Width/Height」 がありますが、、、&lt;br /&gt;
ここで設定を変えても、ウィンドウサイズは変わりません&lt;br /&gt;
（なんでやねん…＞＜）&lt;/p&gt;

&lt;p&gt;どうやら、「前回起動したときのウィンドウサイズ」で起動するみたいです…&lt;br /&gt;
Development Build にしても、しなくても、結果は一緒でした&lt;br /&gt;
初期起動のサイズは、ここじゃないのかな…(´・ω・｀)&lt;/p&gt;

&lt;p&gt;余談ですが、ここで変えた設定は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.\ProjectSettings\ProjectSettings.asset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の中に、テキストファイルで保存されます&lt;/p&gt;

&lt;h1 id=&#34;ウィンドウサイズはプログラムで変更:a0801ebf74281b4200348d8e7619641e&#34;&gt;ウィンドウサイズはプログラムで変更&lt;/h1&gt;

&lt;p&gt;仕方がないので、スクリプトで記載します&lt;/p&gt;

&lt;p&gt;Unityのメニュー &lt;strong&gt;Assets &amp;gt; Create &amp;gt; C# Script&lt;/strong&gt; で新規スクリプトを作ります&lt;/p&gt;

&lt;p&gt;わたしは適当に GameInitial と名付けました（Unity の Project 内に、GameInitial の C#ファイルが追加されます）&lt;/p&gt;

&lt;h2 id=&#34;いーっちばん最初のゲーム起動時をフックしたい:a0801ebf74281b4200348d8e7619641e&#34;&gt;いーっちばん最初のゲーム起動時をフックしたい？&lt;/h2&gt;

&lt;p&gt;もちろん、ウィンドウサイズを変更したいためです&lt;br /&gt;
解像度が小さい/大きいなど&lt;br /&gt;
起動したときに、クライアント端末によってウィンドウサイズを変えたいとかあると思います&lt;/p&gt;

&lt;p&gt;たぶん、現状の Unity 5.3系の最速フック方法は、&lt;strong&gt;RuntimeInitializeOnLoadMethod&lt;/strong&gt; ではないかと…&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RuntimeInitializeOnLoadMethodAttribute&lt;br /&gt;
&lt;a href=&#34;http://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html&#34;&gt;http://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ユーザがアクションを起こす前に動くらしいですが&lt;br /&gt;
実際やってみると、ロゴ起動画面の方が先に動くので&lt;br /&gt;
ほんとの意味の一番最初のウィンドウサイズは、ここでは遅いみたいです&lt;/p&gt;

&lt;p&gt;一応サンプルコード&lt;br /&gt;
MonoBehaviour は無くても動くみたいです&lt;br /&gt;
あと、オブジェクトなどにスクリプトをアタッチしなくてもOKです&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using UnityEngine;

public class GameInitial //: MonoBehaviour
{
    [RuntimeInitializeOnLoadMethod]
    static void OnRuntimeMethodLoad()
    {
        Screen.SetResolution( 640, 960, false, 60);

    }

    //// Use this for initialization
    //void Start()
    //{

    //}

    //// Update is called once per frame
    //void Update()
    //{

    //}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分が知らないだけかもしれませんが、 RuntimeInitializeOnLoadMethodAttribute より早い時点で自分の処理を差し込むことは出来ないみたい…&lt;/p&gt;

&lt;h1 id=&#34;ウィンドウサイズを指定できるコマンドライン引数がある:a0801ebf74281b4200348d8e7619641e&#34;&gt;ウィンドウサイズを指定できるコマンドライン引数がある！&lt;/h1&gt;

&lt;p&gt;結局、起動時のウィンドウサイズは結局どこで更新するんでしょうか…？&lt;/p&gt;

&lt;p&gt;実は、飛び道具的ですが、exe の引数に渡せるみたいです…！（そこか…＞＜&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「Unity スタンドアロンプレイヤーのコマンドライン引数」の項
&lt;a href=&#34;http://docs.unity3d.com/ja/current/Manual/CommandLineArguments.html&#34;&gt;http://docs.unity3d.com/ja/current/Manual/CommandLineArguments.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自分で作った exe の引数に&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-screen-width ：幅&lt;/li&gt;
&lt;li&gt;-screen-height ：高さ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を渡してあげればOKでした&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; xxx.exe -screen-width 300 -screen-height 300
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小さいスクリーンサイズで起動したのちに…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Change-Unity-window-size_03.png&#34; style=&#34;border:solid 5px #e6e6e6&#34;/&gt;&lt;/p&gt;

&lt;p&gt;自分の指定した Screen.SetResolution サイズで起動&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Change-Unity-window-size_04.png&#34; style=&#34;border:solid 5px #e6e6e6&#34;/&gt;&lt;/p&gt;

&lt;p&gt;つまり、引数に自分で好きな数値を渡せるようになってるので&lt;br /&gt;
それと、Screen.SetResolution の指定を同じ大きさにしておけば&lt;br /&gt;
最初から自分自身でサイズを調整できますね&lt;/p&gt;

&lt;p&gt;なんだろなー&lt;br /&gt;
なんで起動時のサイズくらい、すんなり設定できないんでしょうか…謎や～&lt;/p&gt;

&lt;p&gt;もしかしたら、無料版では起動時のロゴを外せないようにするために、プログラマは触れないようになってるのかなー？&lt;/p&gt;

&lt;p&gt;ともあれ、意図したことは出来るようになっているので、まぁ良しとします！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Unity] 2D Spriteにシェーダーをかける</title>
      <link>http://h-sao.com/blog/2016/01/11/unity-shader-2dsprite/</link>
      <pubDate>Mon, 11 Jan 2016 18:00:00 +0900</pubDate>
      
      <guid>http://h-sao.com/blog/2016/01/11/unity-shader-2dsprite/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://h-sao.com/blog/2016/01/04/hello2016/&#34;&gt;今年の初めに&lt;/a&gt;、「Game a Week」という開発手法がすごい！っと書きました&lt;br /&gt;
とりあえず、週に一度は成果物を公開する、の部分を真似してみようかなと&lt;br /&gt;
（やってみて気が付きましたが、実は1週間って、結構長いです）&lt;/p&gt;

&lt;p&gt;今をトキメクGame Engine: &lt;strong&gt;Unity&lt;/strong&gt; について、去年から触る機会があり、ポチポチとやっております&lt;/p&gt;

&lt;p&gt;そしてこれは既知の情報ですが、先週は2Dスプライトにシンプルなグラデーションのシェーダーを適用してみました&lt;/p&gt;

&lt;p&gt;やってみると判るのですが、Unity ではスプライトにシンプルシェーダーだけを適用しようと思っても出来なくて、&lt;br /&gt;
先に結論を書いておくと、スプライトとして扱う場合は必ず何かしらのテクスチャアセットが必要でした&lt;br /&gt;
そのメモと感想文になります&lt;/p&gt;

&lt;p&gt;2016年1月11日現在、Unityのバージョンは 5.3.1 です&lt;/p&gt;

&lt;h1 id=&#34;unity-のシェーダー言語-shaderlab:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;Unity のシェーダー言語：ShaderLab&lt;/h1&gt;

&lt;p&gt;Unity のシェーダーは 「ShaderLab」 という Unity オリジナルのシェーダー言語で記載することになります&lt;br /&gt;
といっても HLSL のラッパーのような言語なので、Unity で使うときのお作法であり、Unity と シェーダーの仲介役の言語、と思って良いみたい&lt;/p&gt;

&lt;h2 id=&#34;最小限の-shaderlab:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;最小限の ShaderLab&lt;/h2&gt;

&lt;p&gt;最小限の ShaderLab の枠組みはこんな感じ&lt;br /&gt;
（これより削ると、エラーが出た）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// BG_shader.shader
// 最小限の ShaderLab
Shader &amp;quot;Custom/BG_shader&amp;quot; {
    SubShader
    {
        Pass {}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際に、このカスタムシェーダーをマテリアルに適用するとこんな感じ&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_00.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;何もしないマテリアルを作ることが出来ました&lt;/p&gt;

&lt;h2 id=&#34;シンプルなグラデーション:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;シンプルなグラデーション&lt;/h2&gt;

&lt;p&gt;今回、ゲーム背景を単純なカラーグラデーションにしようと思ったので、そういうシンプルシェーダーを書いていきます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// BG_shader.shader
// 黄色くグラデーションする
Shader &amp;quot;Custom/BG_shader&amp;quot; {
    SubShader
    {
        Pass{
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            // VS2015のグラフィックデバックON
            #pragma enable_d3d11_debug_symbols

            struct VertexInput {
                float4 pos:  POSITION;    // 3D空間座標
                float2 uv:   TEXCOORD0;   // テクスチャ座標
            };

            struct VertexOutput {
                float4 v:    SV_POSITION; // 2D座標
                float2 uv:   TEXCOORD0;   // テクスチャ座標
            };

            // 頂点 shader
            VertexOutput vert(VertexInput input)
            {
                VertexOutput output;
                output.v = mul(UNITY_MATRIX_MVP, input.pos);
                output.uv = input.uv;

                return output;
            }

            // ピクセル shader
            fixed4 frag( VertexOutput output) : SV_Target
            {
                float2 tex = output.uv;
                // 黄色→白色のグラデーション
                return fixed4( 1.0, 1.0, 1.0 - tex.y, 1.0);
            }

            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちょっとマテリアルではわかりにくいですけど、一応、線形にグラデーションされています&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_01.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;2d-sprite-に適用する方法:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;2D Sprite に適用する方法&lt;/h1&gt;

&lt;p&gt;シンプルなシェーダーとマテリアルが出来たので、実際に、Sprite に登録します&lt;/p&gt;

&lt;h2 id=&#34;sprite-と-material-だけでは足りない:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;Sprite と Material だけでは足りない&lt;/h2&gt;

&lt;p&gt;ただし、ちょっとここでクセがあって、このマテリアルを Sprite にアタッチしても、何も起こりません&lt;br /&gt;
それどころか、ワーニングメッセージが…&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_02.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Material does not have a _MainTex texture property. It is required for SpriteRenderer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;あら…&lt;br /&gt;
Sprite Renderer に登録するマテリアルには、テクスチャが必要ということみたいです&lt;br /&gt;
シェーダーに戻って、言われているとおり、 _MainTex にテクスチャを登録します&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// BG_shader.shader の Properties を追加
    Properties
    {
        _MainTex( &amp;quot;2D Texture&amp;quot;, 2D ) = &amp;quot;white&amp;quot; {}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テクスチャを登録できるし、デフォルトでは white テクスチャを使いますよ。という意味になります&lt;br /&gt;
ちなみに、_MainTex() の内蔵テクスチャには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;gray&lt;/li&gt;
&lt;li&gt;bump&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の4種類が用意されています&lt;br /&gt;
* ShaderLab: Properties - Unity Documentation&lt;br /&gt;
 &lt;a href=&#34;http://docs.unity3d.com/Manual/SL-Properties.html&#34;&gt;http://docs.unity3d.com/Manual/SL-Properties.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_03.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;マテリアルにテクスチャを持つ設定にしました&lt;/p&gt;

&lt;h2 id=&#34;sprite-には-ベースとしてリアルな-texture-が必要:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;Sprite には、ベースとしてリアルな Texture が必要&lt;/h2&gt;

&lt;p&gt;Sprite のワーニングも消えたのですが、やはりシーンに Sprite object が表示されません&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_04.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;どうやら、Sprite はあくまで、テクスチャ画像を表示させるための機能に特化しており、マテリアルだけでは動作しない様です&lt;/p&gt;

&lt;p&gt;仕方がないので、Sprite 用のテクスチャを用意します&lt;br /&gt;
サイズ感がよくわからなかったのですが、 white.jpg という 8*8 のテクスチャを Assets の下に入れました&lt;/p&gt;

&lt;p&gt;Sprite の Inspector にて、Sprite Rendere &amp;gt; Sprite にて white テクスチャを選択します&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;あぁ…これ、デフォルトで白いテクスチャくらい、システムで用意してほしいなかと思いましたが、まぁしょーがないです&lt;br /&gt;
&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_05.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;でたー&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://h-sao.com/pic/Unity-Shader-2DSprite_06.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;まとめ:9da674eae95fd048ddb2e278fe6c87b1&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;シンプルな 3D model では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mesh Renderer&lt;/strong&gt;&lt;br /&gt;
→ &lt;strong&gt;Material&lt;/strong&gt; (たとえば Standard Shader)&lt;br /&gt;
　→ &lt;strong&gt;Texture&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という構造なので、&lt;/p&gt;

&lt;p&gt;2D Sprite では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sprite Renderer&lt;/strong&gt;&lt;br /&gt;
→ &lt;strong&gt;Material&lt;/strong&gt; or &lt;strong&gt;Texture&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なのかなーと思っていたのですが、実際には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sprite Renderer&lt;/strong&gt;&lt;br /&gt;
→ &lt;strong&gt;Material&lt;/strong&gt;&lt;br /&gt;
　→ &lt;strong&gt;Texture&lt;/strong&gt; (Shader の _MainTex() )&lt;br /&gt;
→ &lt;strong&gt;Sprite&lt;/strong&gt;&lt;br /&gt;
　→ &lt;strong&gt;Texture&lt;/strong&gt; (リアル画像)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という構造が必要でした&lt;/p&gt;

&lt;p&gt;これを受けて、&lt;/p&gt;

&lt;p&gt;「え、シンプルなシェーダーのみを適用したいなら、&lt;br /&gt;
Sprite でなくて 3D Plane Model にしたらいいんでない？」&lt;/p&gt;

&lt;p&gt;という疑問が出てきましたが、&lt;br /&gt;
実際のゲーム制作においては、シチュエーション依存ですかね…&lt;br /&gt;
今回のわたしの場合は、Sprite を採用しました&lt;/p&gt;

&lt;p&gt;この記事の Unity プロジェクト（ソース、アセット）を Github に置いておきます&lt;br /&gt;
&lt;a href=&#34;https://github.com/h-sao/UnitySampleCode/tree/master/SpriteGradationalShader&#34;&gt;https://github.com/h-sao/UnitySampleCode/tree/master/SpriteGradationalShader&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;何かの参考になれば幸いです&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>