<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Powershell on Effectiveさお</title>
    <link>http://h-sao.com/tags/powershell/index.xml</link>
    <description>Recent content in Powershell on Effectiveさお</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright © Sao Haruka&lt;br&gt; Powered by [Hugo](http://gohugo.io).</copyright>
    <atom:link href="http://h-sao.com/tags/powershell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[PowerShell] 連想配列をソートしてforeachで一個づつ取り出す</title>
      <link>http://h-sao.com/blog/2014/07/02/sort-arrays-and-retrieve-one-by-one-for-powershell/</link>
      <pubDate>Wed, 02 Jul 2014 17:46:00 +0900</pubDate>
      
      <guid>http://h-sao.com/blog/2014/07/02/sort-arrays-and-retrieve-one-by-one-for-powershell/</guid>
      <description>

&lt;p&gt;PowerShell で連想配列を用いた時のソート＆foreach のサンプルがなかなか探せなかったのでメモします&lt;/p&gt;

&lt;p&gt;とある連想配列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; $tbl = @{
&amp;gt;&amp;gt;       k00 = &amp;quot;orange&amp;quot;;
&amp;gt;&amp;gt;       k01 = &amp;quot;peach&amp;quot;;
&amp;gt;&amp;gt;       k02 = &amp;quot;apple&amp;quot;
&amp;gt;&amp;gt;  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力は簡単&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; $tbl

Name                           Value
----                           -----
k01                            peach
k02                            apple
k00                            orange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソートの出力も簡単&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; $tbl.GetEnumerator() | Sort-Object Value

Name                           Value
----                           -----
k02                            apple
k00                            orange
k01                            peach

# もしくは

PS C:\&amp;gt; $tbl.GetEnumerator() | sort Value

Name                           Value
----                           -----
k02                            apple
k00                            orange
k01                            peach
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを一つづつ取り出して処理したい&lt;/p&gt;

&lt;h2 id=&#34;単に-foreach-で取り出すとき&#34;&gt;単に foreach で取り出すとき&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; foreach( $k in $tbl.Keys ){
&amp;gt;&amp;gt;   Write-Output $k
&amp;gt;&amp;gt;   Write-Output $tbl[ $k ]
&amp;gt;&amp;gt;   Write-Output &#39;-----&#39;
&amp;gt;&amp;gt; }

k01
peach
-----
k02
apple
-----
k00
orange
-----
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;さらにソートして-foreach-で取り出すとき&#34;&gt;さらにソートして foreach で取り出すとき&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; $tbl.GetEnumerator() | sort Value |
&amp;gt;&amp;gt;   ForEach-Object{
&amp;gt;&amp;gt;       Write-Output $_.Name
&amp;gt;&amp;gt;       Write-Output $_.Value
&amp;gt;&amp;gt;       Write-Output &#39;-----&#39;
&amp;gt;&amp;gt;   }

k02
apple
-----
k00
orange
-----
k01
peach
-----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ForEach-Object&lt;/strong&gt; を使いました
ただの foreach() でも出来ると思うんですけど、私的用途が満たせたので、これ以上は調べてないです&lt;/p&gt;

&lt;p&gt;検索で、「powershell foreach ソート -perl」 などで検索しても、日本語の情報があまり出てこなかったので、参考になれば幸いです(^^)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[PowerShell] 32bitと64bitの使い分け</title>
      <link>http://h-sao.com/blog/2014/04/19/about-powershell-x32-and-x64/</link>
      <pubDate>Sat, 19 Apr 2014 21:46:45 +0900</pubDate>
      
      <guid>http://h-sao.com/blog/2014/04/19/about-powershell-x32-and-x64/</guid>
      <description>&lt;p&gt;PowerShellにはちゃんと 32bit版と 64bit版が備わっています&lt;/p&gt;

&lt;p&gt;Windows2008 R2&lt;br /&gt;
Windows2012 R2&lt;br /&gt;
共に同じ場所にあります(~o~)&lt;/p&gt;

&lt;p&gt;64bit版&lt;br /&gt;
&lt;strong&gt;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;32bit版&lt;br /&gt;
&lt;strong&gt;C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;デフォルトの64bitマシンであれば、コンソールで&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; powershell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、64bitモードが立ち上がります&lt;/p&gt;

&lt;p&gt;これはどういうことかというと、64bitのアプリから使うライブラリなどは、64bitでないとダメってことです&lt;/p&gt;

&lt;p&gt;何にはまったかというと、PowerShell から System.Data.OracleClient に接続するとき&lt;/p&gt;

&lt;p&gt;たとえDBサーバが 64bit Oracle だったとしても&lt;br /&gt;
Oracle Client はデフォルトでは 32bit になっているようです&lt;/p&gt;

&lt;p&gt;powershell から oracle に接続しようとしたときこんな感じになります&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# アセンブリのロード
[void][System.Reflection.Assembly]::LoadWithPartialName(&amp;quot;System.Data.OracleClient&amp;quot;)

# 接続
$conn_str = &amp;quot;Data Source=saoDB;User ID=sao;Password=password;Integrated Security=false;&amp;quot;
$ora_conn = New-Object System.Data.OracleClient.OracleConnection($conn_str)

# インスタンス
$ora_cmd = New-Object System.Data.OracleClient.OracleCommand
$ora_cmd.Connection = $ora_conn

# データベースに接続
$ora_conn.Open()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（参考）powerShellからOracleを使う（接続・切断）&lt;br /&gt;
&lt;a href=&#34;http://harikofu.blog.fc2.com/blog-entry-114.html&#34;&gt;http://harikofu.blog.fc2.com/blog-entry-114.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このDB接続直後に、64bit のPowerShell だと&lt;br /&gt;
こんなエラーが出ます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;0&amp;quot; 個の引数を指定して &amp;quot;Open&amp;quot; を呼び出し中に例外が発生しました: &amp;quot;Oracle クライアント ライブラリを読み込もうとしましたが、BadImageFormatException が発行されました。この問題は、32 ビットの Oracle クライアント コンポーネントが
インストールされている環境で 64 ビット モードを実行すると発生します。&amp;quot;
発生場所 行:1 文字:22
+ $ora_conn.Open &amp;lt;&amp;lt;&amp;lt;&amp;lt; ()
    + CategoryInfo          : NotSpecified: (:) []、MethodInvocationException
    + FullyQualifiedErrorId : DotNetMethodException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;問題解決方法は2つ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Oracle Client を 64bit版をインストールする（たとえDBサーバ上であっても…&lt;/li&gt;
&lt;li&gt;呼び出す側のPowerShellを 32bit版にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既存の稼働環境に影響を与えない様にするという意味では&lt;br /&gt;
不毛ですが後者を選択すると波風立てずにコトを済ませられます&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>